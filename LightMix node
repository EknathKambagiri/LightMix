set cut_paste_input [stack 0]
version 13.0 v2
push $cut_paste_input
Group {
 name LightMix_v2
 selected true
 xpos 762
 ypos 3
 addUserKnob {20 LightMix}
 addUserKnob {20 Build n 1}
 addUserKnob {1 prefix l "Light Prefix"}
 prefix RGBA_
 addUserKnob {26 "" -STARTLINE}
 addUserKnob {22 buildLightGroups l "Build Light Groups" T "import nuke\n\ndef create_group_with_shuffle_contactsheet_and_output():\n\n    # Create a Group node\n    group_node = nuke.thisNode()  # Create group with a white color\n\n    # Get the first input (assumed to be a Read node or a similar multi-channel input)\n    input_node = group_node.input(0)\n    if not input_node:\n        nuke.message(\"Connect to a Read Node!\")\n        return\n\n\n    prefix = group_node\['prefix'].value()\n\n    # Get the list of layers in the Read node\n    layers = input_node.channels()\n\n    # Extract unique layer names (before the dot separator), excluding crypto layers\n    unique_layers = sorted(set(\[channel.split('.')\[0] for channel in layers if (channel.startswith(prefix))]))\n\n    if not unique_layers:\n        nuke.message(\"No LightGroups are Found!\")\n        return\n\n    # Enter the group to check for existing nodes\n    group_node.begin()\n\n    # Check if a node named 'Merge1' exists inside the group\n    existing_merge_node = None\n    for node in nuke.allNodes():\n        if node.Class() == \"Merge2\" and node.name() == \"Merge1\":\n            existing_merge_node = node\n            break\n\n    # If 'Merge1' exists, show a warning message\n    if existing_merge_node:\n        user_response = nuke.ask(\"Would you like to delete the existing LightGroups and create new ones?\")\n        \n        if not user_response:\n            # If user selects 'No', exit the function\n            group_node.end()  # Exit the group before returning\n            return\n\n    protected_knobs = \{\n        \"name\", \"xpos\", \"ypos\", \"tile_color\", \"hide_input\", \"note_font\", \n        \"note_font_size\", \"note_font_color\", \"label\", \"selected\", \"icon\", \n        \"indicators\", \"rootNodeUpdated\", \"cached\", \"disable\", \"dope_sheet\", \n        \"bookmark\", \"postage_stamp\", \"postage_stamp_frame\", \"lifetimeStart\", \n        \"lifetimeEnd\", \"useLifetime\", \"lock_connections\", \"mapsize\", \"window\",\n        \"help\", \"onCreate\", \"onDestroy\", \"knobChanged\", \"updateUI\", \"autolabel\", \"panel\", \"gl_color\",\n        \"Build\", \"prefix\", \"buildLightGroups\"\n    \}\n\n    # Collect all user-defined knobs\n    knobs_to_remove = \[knob for knob in group_node.knobs() if knob not in protected_knobs]\n\n    # Remove all custom knobs (including dividers)\n    for knob_name in knobs_to_remove:\n        try:\n            knob = group_node\[knob_name]\n            group_node.removeKnob(knob)\n\n        except ValueError:\n            print(\"\")\n\n    # Create the Tab Knob to end the collapsible group\n    endGroup = nuke.Tab_Knob(f'end_Build', None, nuke.TABENDGROUP)\n    group_node.addKnob(endGroup)  # Add the group end knob    \n\n    # Add a divider after the button using a Text_Knob\n    Layers_divider_knob = nuke.Text_Knob(\"divider\", \"Solo\")  # Empty label for the divider\n    Layers_divider_knob.setFlag(nuke.HORIZONTAL)  # Flag for horizontal divider\n    group_node.addKnob(Layers_divider_knob)  # Add the divider to the Group node\n\n\n    # Add boolean knobs for each RGBA_ layer\n    for layer in unique_layers:\n\n        stripped_layer_name = layer.replace(\"RGBA_\", \"\")\n\n        bool_knob = nuke.Boolean_Knob(f\"solo_\{layer\}\", f\"\{stripped_layer_name\}\")\n        bool_knob.setValue(False)  # Default to checked (True)\n        group_node.addKnob(bool_knob)\n\n    # Add a divider after the button using a Text_Knob\n    Layers_divider_knob = nuke.Text_Knob(\"divider_solo_end\", \"\")  # Empty label for the divider\n    Layers_divider_knob.setFlag(nuke.HORIZONTAL)  # Flag for horizontal divider\n    group_node.addKnob(Layers_divider_knob)  # Add the divider to the Group node\n\n\n    # Create a group for each RGBA_ layer\n    for layer in unique_layers:\n\n        stripped_layer_name = layer.replace(\"RGBA_\", \"\")\n\n        # Create the Tab Knob to begin a new collapsible group for each layer\n        beginGroup = nuke.Tab_Knob(f'\{stripped_layer_name\}', f'\{stripped_layer_name\}', nuke.TABBEGINCLOSEDGROUP)\n        group_node.addKnob(beginGroup)  # Add the group start knob\n\n\n        bool_knob = nuke.Boolean_Knob(f\"mute_\{layer\}\", f\"mute\")\n        bool_knob.setValue(False)  # Default to checked (True)\n        group_node.addKnob(bool_knob)\n\n        bool_knob = nuke.Boolean_Knob(f\"cc_\{layer\}\", f\"mute_cc\")\n        bool_knob.setValue(False)  # Default to checked (True)\n        group_node.addKnob(bool_knob)\n\n        # Add a floating point knob inside the group with a range from -5 to 5 and default value 0\n        float_knob = nuke.Double_Knob(f\"exp_\{layer\}\", f\"exposure\")\n        float_knob.setRange(-5, 5)  # Set the min and max values\n        float_knob.setValue(0)  # Set the default value\n        group_node.addKnob(float_knob)  # Add the floating knob inside the group\n\n        color_knob = nuke.Color_Knob(f\"color_\{layer\}\", f\"Color\")\n        color_knob.setValue(\[1,1,1])  # Set the default value\n        group_node.addKnob(color_knob)        \n\n\n\n        # Add a divider after the button using a Text_Knob\n        Layers_divider_knob = nuke.Text_Knob(f\"divider_\{layer\}\", \"\")  # Empty label for the divider\n        Layers_divider_knob.setFlag(nuke.HORIZONTAL)  # Flag for horizontal divider\n        group_node.addKnob(Layers_divider_knob)  # Add the divider to the Group node\n\n        # Create the Tab Knob to end the collapsible group\n        endGroup = nuke.Tab_Knob(f'end_\{layer\}', None, nuke.TABENDGROUP)\n        group_node.addKnob(endGroup)  # Add the group end knob\n\n\n        # Add a divider after the button using a Text_Knob\n    Layers_divider_knob = nuke.Text_Knob(\"divider_contactsheet\", \"\")  # Empty label for the divider\n    Layers_divider_knob.setFlag(nuke.HORIZONTAL)  # Flag for horizontal divider\n    group_node.addKnob(Layers_divider_knob)  # Add the divider to the Group node\n\n\n    # Create the Tab Knob to begin a new collapsible group for each layer\n    beginGroup = nuke.Tab_Knob('ContactSheet', 'Contactsheet', nuke.TABBEGINCLOSEDGROUP)\n    group_node.addKnob(beginGroup)  # Add the group start knob\n\n    bool_knob = nuke.Boolean_Knob(\"contactsheet\", \"show Contactsheet\")\n    bool_knob.setValue(False)  # Default to checked (True)\n    group_node.addKnob(bool_knob)\n\n    # Add a floating point knob inside the group with a range from -5 to 5 and default value 0\n    float_knob = nuke.Double_Knob(\"size\", \"text size\")\n    float_knob.setRange(1, 20)  # Set the min and max values\n    float_knob.setValue(10)  # Set the default value\n    group_node.addKnob(float_knob)  # Add the floating knob inside the group\n\n    # Create the Tab Knob to end the collapsible group\n    endGroup = nuke.Tab_Knob('end_contactsheet', None, nuke.TABENDGROUP)\n    group_node.addKnob(endGroup)  # Add the group end knob\n\n\n    Layers_divider_knob = nuke.Text_Knob(\"divider_note\", \"\")  # Empty label for the divider\n    Layers_divider_knob.setFlag(nuke.HORIZONTAL)  # Flag for horizontal divider\n    group_node.addKnob(Layers_divider_knob)  # Add the divider to the Group node\n\n\n    note_knob = nuke.Text_Knob(\"note\", \"\", \"\"\"<span style='color:#666'><b>LightMix v2.0</b></span> <a style=\"color:#666;text-decoration: none;\">- by Eknath Kambagiri</a>\"\"\")\n    group_node.addKnob(note_knob)\n\n\n\n\n    # Store the current node graph context so we can work inside the group\n    group_node.begin()\n\n    for node in nuke.allNodes():\n        nuke.delete(node)\n\n    # Create an Input node inside the group that will connect to the Read node outside the group\n    input_node = nuke.createNode(\"Input\", inpanel=False)\n#    input_node.setInput(0, selected_node)  # Connect the Read node to the Input node inside the group\n    \n\n    remove_rgb_node = nuke.createNode(\"Remove\", inpanel=False)\n    remove_rgb_node.setInput(0, input_node)\n    remove_rgb_node\[\"operation\"].setValue('remove')\n    remove_rgb_node\[\"channels\"].setValue(\"rgb\")\n\n\n    previous_remove_node = remove_rgb_node\n\n    for layer in unique_layers:\n        remove_lgt_node = nuke.createNode(\"Remove\", inpanel=False)\n        remove_lgt_node.setInput(0, previous_remove_node)\n        remove_lgt_node\[\"operation\"].setValue('remove')\n        remove_lgt_node\[\"channels\"].setValue(layer)\n\n        previous_remove_node = remove_lgt_node\n\n    # Deselect all nodes in the current group\n    for node in nuke.allNodes():\n        node.setSelected(False)\n\n    # Create and rename a Shuffle node for each layer inside the group\n    shuffle_nodes = \[]  # List to keep track of shuffle nodes for contact sheet connection\n    exposure_nodes = \[]\n    cc_nodes = \[]\n    mute_nodes = \[]\n    solo_nodes = \[]\n    text_nodes = \[]\n    shuffle_layer_nodes = \[]\n    remove_nodes = \[]\n\n    for layer in unique_layers:\n        # Create a new Shuffle node inside the group\n        shuffle_node = nuke.createNode(\"Shuffle\", inpanel=False)\n        shuffle_node.setInput(0, input_node)  # Connect the Input node inside the group\n        shuffle_node\[\"in\"].setValue(layer)  # Set the layer to shuffle\n        shuffle_node.setName(layer)\n        nuke.autoplace(shuffle_node)\n        shuffle_node.setSelected(False)\n\n        shuffle_nodes.append(shuffle_node)\n\n        # Create an Exposure node after each Shuffle node\n        exposure_node = nuke.createNode(\"EXPTool\", inpanel=False)\n        exposure_node.setInput(0, shuffle_node)  # Connect the Shuffle node to the Exposure node\n        exposure_node.setName(f\"Exp_\{layer\}\")  # Label for the exposure node\n        exposure_node.setSelected(False)  # Deselect the Exposure node after placement\n        exposure_node\[\"mode\"].setValue('Stops')\n        exposure_node\[\"red\"].setExpression(f\"exp_\{layer\}\")  \n        exposure_node\[\"green\"].setExpression(f\"exp_\{layer\}\")\n        exposure_node\[\"blue\"].setExpression(f\"exp_\{layer\}\") \n        exposure_node\[\"disable\"].setExpression(f\"cc_\{layer\}\")  \n\n        exposure_nodes.append(exposure_node)  # Add exposure node to the list\n\n        cc_node = nuke.createNode(\"Multiply\", inpanel = False)\n        cc_node.setInput(0, exposure_node)\n        cc_node.setName(f'cc_\{layer\}')\n        cc_node\[\"channels\"].setValue('rgb')\n        cc_node\[\"value\"].setValue(\[1.0, 1.0, 1.0, 1.0])\n        cc_node\[\"value\"].setExpression(f\"color_\{layer\}\", 0)\n        cc_node\[\"value\"].setExpression(f\"color_\{layer\}\", 1)\n        cc_node\[\"value\"].setExpression(f\"color_\{layer\}\", 2)\n        cc_node\[\"disable\"].setExpression(f\"cc_\{layer\}\")     \n\n        cc_nodes.append(cc_node)   \n\n        mute_node = nuke.createNode(\"Multiply\", inpanel = False)\n        mute_node.setInput(0, cc_node)\n        mute_node.setName(f'mute_\{layer\}')\n        mute_node\[\"channels\"].setValue('rgb')\n        mute_node\[\"value\"].setValue(\[0, 0, 0, 0])\n        mute_node\[\"disable\"].setExpression(f\"!(mute_\{layer\})\")\n\n        mute_nodes.append(mute_node)\n\n    \n        solo_node = nuke.createNode(\"Multiply\", inpanel=False)\n        solo_node.setInput(0, mute_node)      \n        solo_node.setName(f\"solo_\{layer\}\")   \n        solo_node\[\"value\"].setValue(\[0, 0, 0, 0])  \n        # Create the disable expression dynamically based on the layer\n        other_layers = \[l for l in unique_layers if l != layer]        \n        solo_expressions = \[f\"solo_\{other_layer\}\" for other_layer in other_layers]  # solo_ expressions   \n        # Join all the solo expressions with '||' (logical OR)\n        disable_expression = f\"!( \{' || '.join(solo_expressions)\} )\"       \n        # Set the disable expression on the multiply node\n        solo_node\[\"disable\"].setExpression(disable_expression)\n\n        solo_nodes.append(solo_node)\n\n\n        shuffle_layer_node = nuke.createNode(\"Shuffle2\", inpanel=False)\n        shuffle_layer_node.setInput(0, solo_node)  \n        shuffle_layer_node\[\"out1\"].setValue(layer)  # Set the layer to shuffle\n        shuffle_layer_node.setName(f\"copy_\{layer\}\")\n        nuke.autoplace(shuffle_layer_node)\n        shuffle_layer_node.setSelected(False)\n\n        shuffle_layer_nodes.append(shuffle_layer_node)\n\n\n        remove_node = nuke.createNode(\"Remove\", inpanel=False)\n        remove_node.setInput(0, shuffle_layer_node)  \n        remove_node\[\"operation\"].setValue(\"keep\")\n        remove_node\[\"channels\"].setValue(\"rgb\")\n        remove_node\[\"channels2\"].setValue(layer)\n        remove_node.setName(f\"keep_\{layer\}\")\n        nuke.autoplace(remove_node)\n        remove_node.setSelected(False)\n\n        remove_nodes.append(remove_node)\n\n\n        text_node = nuke.createNode(\"Text\", inpanel=False)\n        text_node.setInput(0, remove_node)      \n        text_node.setName(f\"text_\{layer\}\")\n        text_node\[\"message\"].setValue(f'\{layer\}')\n        text_node\[\"xjustify\"].setValue('left')\n        text_node\[\"yjustify\"].setValue('bottom')\n        text_node\[\"size\"].setExpression(\"\[knob parent.size]*10\")\n        text_node\[\"box\"].setExpression(\"50\", 0)  # Left (L)\n        text_node\[\"box\"].setExpression(\"50\", 1)  # Bottom (B)\n        text_node\[\"box\"].setExpression(\"Input1.width-50\", 2)  # Right (R)\n        text_node\[\"box\"].setExpression(\"Input1.height-50\", 3)  # Top (T)\n\n        text_nodes.append(text_node)\n\n\n    # Create the merge node inside the group\n    merge1 = nuke.createNode(\"Merge2\", inpanel=False)\n    merge1.setInput(0, previous_remove_node)\n    merge1\[\"operation\"].setValue('plus')\n    merge1\[\"also_merge\"].setValue('all')\n    # Set the merge node to use the shuffle nodes\n    for idx, remove_node in enumerate(remove_nodes):\n        merge1.setInput(idx+3, remove_node)\n\n    merge1.setInput(1, None)\n    # Deselect the ContactSheet node\n    merge1.setSelected(False)\n\n    copy_alpha = nuke.createNode(\"Copy\", inpanel=False)\n    copy_alpha.setInput(0, merge1)\n    copy_alpha.setInput(1, input_node)\n\n\n\n    contactsheet = nuke.createNode(\"ContactSheet\", inpanel=False)\n    for idx, text_node in enumerate(text_nodes):\n        contactsheet.setInput(idx, text_node)    \n    contactsheet\[\"width\"].setExpression('input.width')\n    contactsheet\[\"height\"].setExpression('input.height')\n    contactsheet\[\"center\"].setValue(True)\n    contactsheet\[\"roworder\"].setValue('TopBottom')\n    contactsheet\[\"rows\"].setExpression('\[expr \{int( (sqrt( \[numvalue inputs] ) ) )\} ] * \[expr \{int( ceil ( (\[numvalue inputs] /(sqrt( \[numvalue inputs] ) ) )) )\} ] < \[numvalue inputs]   ? \[expr \{int( (sqrt( \[numvalue inputs] ) ) )\} ] +1 : \[expr \{int( (sqrt( \[numvalue inputs] ) ) )\} ]')\n    contactsheet\[\"columns\"].setExpression('\[expr \{int( ceil ( (\[numvalue inputs] /(sqrt( \[numvalue inputs] )) )) )\} ]')\n\n\n    switch = nuke.createNode(\"Switch\", inpanel=False)\n    switch.setInput(0, copy_alpha)\n    switch.setInput(1, contactsheet)\n    switch\[\"which\"].setExpression('contactsheet')\n\n\n    # Create the Output node inside the group and connect it to the ContactSheet node\n    output_node = nuke.createNode(\"Output\", inpanel=False)\n    output_node.setInput(0, switch)  # Connect the ContactSheet node to the Output node\n    # Deselect the Output node\n    output_node.setSelected(False)\n\n    # End the group, returning to the main node graph\n    group_node.end()\n\n# Run the function\ncreate_group_with_shuffle_contactsheet_and_output()\n    " +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 text l "" +STARTLINE T "<span style='color:#666'><b>LightMix v2.0</b></span> <a style=\"color:#666;text-decoration: none;\">- by Eknath Kambagiri</a>"}
}
 Input {
  inputs 0
  name Input1
  xpos 0
 }
 Output {
  name Output1
  xpos 0
  ypos 300
 }
end_group
